\chapter{Конструкторская часть}
В этом разделе будут представлены описания используемых типов данных, а также схемы алгоритмов перемножения матриц -- стандартного, Винограда и оптимизации алгоритма Винограда.

\section{Описание используемых типов данных}

При реализации алгоритмов будут использованы следующие типы данных:
\begin{itemize}[label=---]
	\item количество строк -- целое число;
	\item количество столбцов -- целое число;
	\item матрица -- двумерный список целых чисел.
\end{itemize}


\section{Сведения о модулях программы}
Программа состоит из шести модулей:
\begin{enumerate}[label=\arabic*)]
	\item $main.py$ --- файл, содержащий точку входа;
    \item $menu.py$ --- файл, содержащий код меню программы;
    \item $test.py$ --- файл, содержайший код тестирования алгоритмов;
    \item $utils.py$ --- файл, содержащий служебные алгоритмы;
    \item $constants.py$ --- файл, содержайший константы программы;
    \item $algorythms.py$ --- файл, содержащий код всех алгоритмов. \newline
\end{enumerate}

\section{Разработка алгоритмов}
На рисунке \ref{img:stand_alg} представлена схема алгоритма для стандартного умножения матриц. На рисунках \ref{img:vin_alg1}--\ref{img:vin_alg2} схема алгоритма Винограда умножения матриц, а на \ref{img:opt_vin_alg1}--\ref{img:opt_vin_alg2} -- схема оптимизированного алгоритма Винограда.

\imgScale{0.8}{stand_alg}{Схема стандартного алгоритма умножения матриц}
\imgScale{0.6}{vin_alg1}{Схема умножения матриц по алгоритму Винограда (часть 1)}
\imgScale{0.6}{vin_alg2}{Схема умножения матриц по алгоритму Винограда (часть 2)}
\imgScale{0.6}{opt_vin_alg1}{Схема умножения матриц по оптимизированному алгоритму Винограда (часть 1)}
\imgScale{0.6}{opt_vin_alg2}{Схема умножения матриц по оптимизированному алгоритму Винограда (часть 2)}

\clearpage


\section{Модель вычислений}

Чтобы провести вычисление трудоемкости алгоритмов умножения матриц, введем модель вычислений~\cite{model}:

\begin{enumerate}
	\item Операции из списка (\ref{for:opers}) имеют трудоемкость 1;
	\begin{equation}
		\label{for:opers}
		+, -, *, /, \%, ==, !=, <, >, <=, >=, [], ++, {-}-
	\end{equation}
	\item Трудоемкость оператора выбора \code{if условие then A else B} рассчитывается, как (\ref{for:if});
	\begin{equation}
		\label{for:if}
		f_{if} = f_{\text{условия}} +
		\begin{cases}
			f_A, & \text{если условие выполняется,}\\
			f_B, & \text{иначе.}
		\end{cases}
	\end{equation}
	\item Трудоемкость цикла рассчитывается, как (\ref{for:for});
	\begin{equation}
		\label{for:for}
		f_{for} = f_{\text{инициализации}} + f_{\text{сравнения}} + N(f_{\text{тела}} + f_{\text{инкремента}} + f_{\text{сравнения}})
	\end{equation}
	\item Трудоемкость вызова функции равна 0.
\end{enumerate}


\section{Трудоемкость алгоритмов}

Рассчитаем трудоемкость алгоритмов умножения матриц.
\clearpage

\subsection{Стандартный алгоритм умножения матриц}

Для стандартного алгоритма умножения матриц трудоемкость будет слагаться из:
\begin{itemize}[label=---]
	\item внешнего цикла по $i \in [1..M]$, трудоёмкость которого: $f = 2 + M \cdot (2 + f_{body})$;
	\item цикла по $j \in [1..N]$, трудоёмкость которого: $f = 2 + 2 + N \cdot (2 + f_{body})$;
	\item цикла по $k \in [1..K]$, трудоёмкость которого: $f = 2 + 2 + 14K$. \newline
\end{itemize}

Поскольку трудоемкость стандартного алгоритма равна трудоемкости внешнего цикла, то:

\begin{equation}
	\begin{split}
	\label{for:standard}
	f_{standard} &= 2 + M \cdot (4 + N \cdot (4 + 14K)) = 2 + 4M + 4MN + 14MNK\\ &\approx 14MNK
	\end{split}
\end{equation}


\subsection{Алгоритм Винограда}

Чтобы вычислить трудоемкость алгоритма Винограда, нужно учесть следующее:

\begin{itemize}[label=---]
	\item создания и инициализации массивов $a_{tmp}$ и $b_{tmp}$, трудоёмкость которых (\ref{for:init});
	\begin{equation}
		\label{for:init}
		f_{init} = M + N;
	\end{equation}

	\item заполнения массива $a_{tmp}$, трудоёмкость которого (\ref{for:ATMP});
	\begin{equation}
		\label{for:ATMP}
		f_{a_{tmp}} = 2 + K (2 + \frac{M}{2} \cdot 11);
	\end{equation}

	\item заполнения массива $b_{tmp}$, трудоёмкость которого (\ref{for:BTMP});
	\begin{equation}
		\label{for:BTMP}
		f_{b_{tmp}} = 2 + K (2 + \frac{N}{2} \cdot 11);
	\end{equation}

	\item цикла заполнения для чётных размеров, трудоёмкость которого (\ref{for:cycle});
	\begin{equation}
		\label{for:cycle}
		f_{cycle} = 2 + M \cdot (4 + N \cdot (11 + \frac{K}{2} \cdot 23));
	\end{equation}

	\item цикла, который дополнительно нужен для подсчёта значений при нечётном размере матрицы, трудоемкость которого (\ref{for:last});
	\begin{equation}
		\label{for:last}
		f_{last} = \begin{cases}
			2, & \text{чётная,}\\
			4 + M \cdot (4 + 14N), & \text{иначе.}
		\end{cases}
	\end{equation}
\end{itemize}

Тогда для худшего случая (нечётный общий размер матриц) имеем (\ref{for:bad}).
\begin{equation}
	\label{for:bad}
	f_{worst} =  f_{a_{tmp}} + f_{b_{tmp}} + f_{cycle} + f_{last}\approx 11.5 \cdot MNK
\end{equation}

Для лучшего случая (чётный общий размер матриц) имеем (\ref{for:good}).
\begin{equation}
	\label{for:good}
f_{best} =  f_{a_{tmp}} + f_{a_{tmp}} + f_{cycle} + f_{last} \approx 11.5 \cdot MNK
\end{equation}


\subsection{Оптимизированный алгоритм Винограда}

Оптимизация заключается в:
\begin{itemize}[label=---]
	\item кэшировании значения $\frac{N}{2}$ в циклах;
    \item использовании побитового сдвига вместо умножения на 2;
    \item замены операции сложения и вычитания на операции $+=$ и $-=$ соответственно. \newline
\end{itemize}

Тогда трудоемкость оптимизированного алгоритма Винограда состоит из:

\begin{enumerate}[label=\arabic*)]
	\item создания и инициализации массивов $a_{tmp}$ и $b_{tmp}$ (\ref{for:init});

	\item заполнения массива $a_{tmp}$, трудоёмкость которого (\ref{for:ATMP});

	\item заполнения массива  $b_{tmp}$, трудоёмкость которого (\ref{for:BTMP});

	\item цикла заполнения для чётных размеров, трудоёмкость которого (\ref{for:impr_cycle});
	\begin{equation}
		\label{for:impr_cycle}
		f_{cycle} =2 + M \cdot (4 + N \cdot (11 + \frac{K}{2} \cdot 18));
	\end{equation}

	\item условие, которое нужно для дополнительных вычислений при нечётном размере матрицы, трудоемкость которого (\ref{for:impr_last});
	\begin{equation}
		\label{for:impr_last}
		f_{last} =
		\begin{cases}
			1, & \text{чётная,}\\
			4 + M \cdot (4 + 10N), & \text{иначе.}
		\end{cases}
	\end{equation}
\end{enumerate}

Тогда для худшего случая (нечётный общий размер матриц) имеем (\ref{for:bad_impr}).
\begin{equation}
	\label{for:bad_impr}
	f_{worst} = f_{MH} + f_{MV} + f_{cycle} + f_{last} \approx 9MNK
\end{equation}

Для лучшего случая (чётный общий размер матриц) имеем (\ref{for:good_impr}).
\begin{equation}
	\label{for:good_impr}
	f_{best} = f_{MH} + f_{MV} + f_{cycle} + f_{last} \approx 9MNK
\end{equation}


\section{Классы эквивалентности функционального тестирования}

Для функциональные тестирования выделены классы эквивалентности, представленные ниже.

\begin{enumerate}
	\item Одна из матриц -- пустая;
	\item Количество столбцов одной матрицы не равно количеству строк второй матрицы;
	\item Перемножение квадратных матриц;
	\item Перемножение матриц разных размеров (при этом количество столбцов одной матрицы не равно количеству строк второй матрицы).
\end{enumerate}


\section*{Вывод}

В данном разделе были построены схемы алгоритмов умножения матриц, рассматриваемых в лабораторной работе, были описаны классы эквивалентности для функционального тестирования и модули программы.
Проведённая теоретическая оценка трудоемкости алгоритмов показала, что в трудоёмкость выполнения алгоритма Винограда в любом случае в 1.2 раза меньше, чем у стандартного алгоритма умножения матриц.
